<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Document</title>
        <link rel="stylesheet" href="github-markdown.css">
        <style>
            .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 980px;
                margin: 0 auto;
                padding: 45px;
            }
        
            @media (max-width: 767px) {
                .markdown-body {
                    padding: 15px;
                }
            }
        </style>
    </head>
    <body class="markdown-body">
    <h1>Segmenting with SRX</h1>
<p>This is a short guide about segmentation using the SRX standard in OpenXLIFF. </p>
<h2>Default ruleset</h2>
<p>I think a simple example can be useful, so consider the following scenario. The following JSON file needs to be prepared for translation (converted to XLIFF):</p>
<pre><code class="language-json">{
    &quot;paragraph&quot;: &quot;This is one sentence. This is another sentence!! Mrs. 
    are a married person. The U.S.A. is a great country, e.g. not like 
    the US. The Dept. Of Finance has the blessing of Rev. Johnson. Let's 
    go climb Mnt. Everest.&quot;
}
</code></pre>
<p>You may create an XLIFF file with the OpenXLIFF library:</p>
<pre><code class="language-bash">bash ~/Apps/maxprograms/OpenXLIFF/convert.sh -file file.json -srcLang en \
-tgtLang el -type JSON -embed -xliff file.xlf -2.0
</code></pre>
<p>The OpenXLIFF library uses segmentation by default (using the built-in <a href="https://github.com/rmraya/OpenXLIFF/blob/master/srx/default.srx">default ruleset</a>), and produces the following segments: </p>
<pre><code>✅ This is one sentence.
✅ This is another sentence!!
✅ Mrs. are a married person.
✅ The U.S.A. is a great country, e.g. not like the US.
❌ The Dept.
❌ Of Finance has the blessing of Rev. Johnson.
❌ Let's go climb Mnt.
❌ Everest.
</code></pre>
<!-- 

<pre><code class="language-xml">&lt;segment id=&quot;0-0&quot;&gt;
  &lt;source&gt;This is one sentence.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-1&quot;&gt;
  &lt;source&gt; This is another sentence!!&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-2&quot;&gt;
  &lt;source&gt; Mrs. are a married person.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-3&quot;&gt;
  &lt;source&gt; The U.S.A. is a great country, e.g. not like the US.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-4&quot;&gt;
  &lt;source&gt; The Dept.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-5&quot;&gt;
  &lt;source&gt; Of Finance has the blessing of Rev. Johnson.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-6&quot;&gt;
  &lt;source&gt; Let's go climb Mnt.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-7&quot;&gt;
  &lt;source&gt; Everest.&lt;/source&gt;
&lt;/segment&gt;
</code></pre>



<pre><code class="language-xml">&lt;segment id=&quot;0-0&quot;&gt;
  &lt;source&gt;This is one sentence.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-1&quot;&gt;
  &lt;source&gt; This is another sentence!!&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-2&quot;&gt;
  &lt;source&gt; Mrs. are a married person.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-3&quot;&gt;
  &lt;source&gt; The U.S.A. is a great country, e.g. not like the US.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-4&quot;&gt;
  &lt;source&gt; The Dept. Of Finance has the blessing of Rev. Johnson.&lt;/source&gt;
&lt;/segment&gt;
&lt;segment id=&quot;0-5&quot;&gt;
  &lt;source&gt; Let's go climb Mnt. Everest.&lt;/source&gt;
&lt;/segment&gt;
</code></pre>


-->

<p>You can see that the default segmentation rules correctly recognize "Mrs.", "U.S.A.", "e.g." and "Rev." as abbreviations and did not start a new segment after those. </p>
<p>However, it fails to recognize "Dept." and "Mnt.", hence splitting the last two sentences in two parts. This kind of segmentation defect may be more or less common depending on the content, but it's a common practice to fix them.</p>
<h2>Customizing rules</h2>
<p>To amend the problem above, one can use a custom SRX. I have made a copy of the custom.srx included in the OpenXLIFF library, and added a couple of rules that prevent breaking at those two points:</p>
<pre><code class="language-xml">&lt;rule break=&quot;no&quot;&gt;
    &lt;beforebreak&gt;Dept\.&lt;/beforebreak&gt;
    &lt;afterbreak&gt;\sOf&lt;/afterbreak&gt;
&lt;/rule&gt;
&lt;rule break=&quot;no&quot;&gt;
    &lt;beforebreak&gt;Mnt\.&lt;/beforebreak&gt;
    &lt;afterbreak&gt;\s(Everest|Kilimanjaro)&lt;/afterbreak&gt;
&lt;/rule&gt;
</code></pre>
<p>I can now use the <code>-srx</code> argument to point to my segmentation rules: </p>
<pre><code class="language-bash">bash ~/Apps/maxprograms/OpenXLIFF/convert.sh -file file.json -srcLang en \ 
-tgtLang el -type JSON -embed -xliff file.xlf -2.0 -srx custom.srx
</code></pre>
<p>The result is correct now: </p>
<pre><code>✅ This is one sentence.
✅ This is another sentence!!
✅ Mrs. are a married person.
✅ The U.S.A. is a great country, e.g. not like the US.
✅ The Dept. Of Finance has the blessing of Rev. Johnson.
✅ Let's go climb Mnt. Everest.
</code></pre>
<p>This kind of rule customization is a common operation in the preparation of translation projects, regardless of the preparation tool used (SRX is a standard that all modern translation tools should understand).</p>
<h2>Update SRX rules</h2>
<p>One can edit the SRX file directly as XML (assuming good knowledge of the SRX standard) or by other means, but there are off-the-shelf editors for that, e.g. <a href="https://www.maxprograms.com/products/srxeditor.html">SRXEditor</a>).</p>
<h2>References</h2>
<p>Some more info:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Segmentation_Rules_eXchange">https://en.wikipedia.org/wiki/Segmentation_Rules_eXchange</a></li>
</ul>
<p>OpenXLIFF's default ruleset:</p>
<ul>
<li><a href="https://github.com/rmraya/OpenXLIFF/blob/master/srx/default.srx">https://github.com/rmraya/OpenXLIFF/blob/master/srx/default.srx</a></li>
</ul>
    </body>
    </html>
    